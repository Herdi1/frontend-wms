/*!
 * vue-nested-json-to-csv v0.0.23
 * (c) Dan Clark
 * Released under the MIT License.
 */
'use strict';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script = {
  name: 'vue-nested-json-to-csv',
  // Watched props/computed properties
  watch: {
    // Deep watch for the fields prop.
    // When this prop is changed, re-filter
    // the data, triggering the
    // filtering/filtered events.
    fields: {
      handler: function handler() {
        this.filterData();
      },
      deep: true
    },
    unfilteredData: {
      handler: function handler() {
        this.filterData();
      },
      deep: true
    }
  },
  // Computed properties
  computed: {
    rootType: function rootType() {
      switch (Array.isArray(this.unfilteredData)) {
        case true:
          return 'array';

        case false:
          switch (_typeof(this.unfilteredData)) {
            case 'object':
              return 'object';

            default:
              this.error('Unexpected root data type: ' + _typeof(this.unfilteredData));
              return 'object';
          }

      }
    },
    // Unaliased fields. This returns the
    // field names that are used to query
    // the unfilteredData.
    unaliasedFields: function unaliasedFields() {
      // Only proceed if there are one
      // or more items in the fields prop,
      // otherwise, return an empty array.
      if (this.fields.length > 0) {
        // As the component allows for either
        // a single-dimensional array of strings
        // as field names (where the strings
        // will be treated as both the aliased
        // and unaliased field names), check
        // whether the first item in the fields
        // prop is a string. If so, assume that
        // an array of strings has been provided.
        // 
        // If the first item in the fields prop
        // is an object, assume that an array
        // of objects containing aliased and
        // unaliased field names has been provided.
        if (typeof this.fields[0] == 'string') {
          // An array of string field names
          // has been provided, so this can
          // just be returned as the unaliased
          // fields array.
          return this.fields;
        } else if (_typeof(this.fields[0]) == 'object') {
          try {
            // An array of objects containing
            // name and alias properties has been
            // provided, so pluck the name
            // property from these.
            return this.fields.map(function (field) {
              return field.name;
            });
          } catch (error) {
            this.error(error);
            return [];
          }
        } else {
          // If a non-string, non-object first element
          // of fields prop, return an empty array.
          this.warn('Invalid type encountered in fields prop at index 0. Expected string or object.');
          return [];
        }
      } else {
        // If no items are found in the fields prop,
        // return an empty array.
        this.warn('No items found in the fields prop.');
        return [];
      }
    },
    // Alised fields. This returns the
    // field names that are displayed to
    // the user and used for exporting
    // data.
    aliasedFields: function aliasedFields() {
      // Only proceed if there are one
      // or more items in the fields prop,
      // otherwise, return an empty array.
      if (this.fields.length > 0) {
        // As the component allows for either
        // a single-dimensional array of strings
        // as field names (where the strings
        // will be treated as both the aliased
        // and unaliased field names), check
        // whether the first item in the fields
        // prop is a string. If so, assume that
        // an array of strings has been provided.
        // 
        // If the first item in the fields prop
        // is an object, assume that an array
        // of objects containing aliased and
        // unaliased field names has been provided.
        if (_typeof(this.fields[0]) == 'object') {
          // An array of objects containing
          // name and alias properties has been
          // provided, so pluck the alias
          // property from these.
          return this.fields.map(function (field) {
            return field.alias;
          });
        } else if (typeof this.fields[0] == 'string') {
          // An array of string field names
          // has been provided, so this can
          // just be returned as the aliased
          // fields array.
          return this.fields;
        } else {
          // If a non-string, non-object first element
          // of fields prop, return an empty array.
          this.warn('Invalid type encountered in fields prop at index 0. Expected string or object.');
          return [];
        }
      } else {
        // If no items are found in the fields prop,
        // return an empty array.
        this.warn('No items found in the fields prop.');
        return [];
      }
    },
    // Return the unfiltered data passed to the
    // component. Check whether the object
    // or json prop has been used and return
    // an object in either case. If both are
    // provided, the object prop takes precedence.
    // 
    // If neither prop is provided, return an empty
    // object. 
    unfilteredData: function unfilteredData() {
      if (this.object) {
        return this.object;
      } else if (this.json) {
        try {
          return JSON.parse(this.json);
        } catch (error) {
          this.error('Unable to parse JSON in json prop. ' + error);
          return {};
        }
      } else {
        this.warn('Neither the json or object prop has been passed any data.');
        return {};
      }
    }
  },
  // Component data
  data: function data() {
    return {
      // Array to store filtered data.
      // This will be used when emitting
      // events and exporting data.
      filteredData: []
    };
  },
  // Component methods
  methods: {
    // If the errors prop is set to true,
    // log the passed message as a warning.
    warn: function warn(msg) {
      if (this.errors == true) {
        // eslint-disable-next-line
        console.warn('JsonToCsv: ' + msg);
      }
    },
    // If the errors prop is set to true,
    // log the passed message as an error.
    error: function error(msg) {
      if (this.errors == true) {
        // eslint-disable-next-line
        console.error('JsonToCsv: ' + msg);
      }
    },
    // Method used to parse dot notation
    // and dive into the provided object
    // to retrieve the desired property.
    // Returns an empty string where a
    // property cannot be found.
    // 
    // Where an array of objects is 
    // encountered, queries each one and 
    // returns an array of values.
    // 
    // Where an array of strings is 
    // encountered as the value for the
    // desired property, these are
    // concatenated and returned delimited
    // by the concatenationCharacters
    getProperty: function getProperty(propertyName, object) {
      var _this = this;

      // Split the property name into an array
      // of properties by dot notation
      var parts = propertyName.split("."); // Create a copy of the parts
      // array. This will be truncated when
      // accessing nested data, as the dot
      // notation will have the first i+1
      // elements removed when calling this
      // function recursively.

      var truncated = parts; // Get the number of levels of nesting
      // implied by the length of the
      // dot notation

      var length = parts.length; // Initialise iterator

      var i; // Assign the provided data object
      // to the property variable.
      // This is treated as the first
      // 'level' in querying nested
      // objects.

      var property = object; // Initialise data to be returned
      // to an empty array.

      var data = []; // Loop through each level of the
      // dot notation

      for (i = 0; i < length; i++) {
        // Refresh the copy of the truncated
        // parts array and remove the number
        // of elements from the beginning
        // corresponding to the progress through
        // the dot notation.
        truncated = parts;
        truncated.splice(0, i); // Amend behaviour dependent on
        // type of data being queried in
        // this iteration.

        switch (_typeof(property)) {
          // If the queried data is of type object,
          // check whether this is an array or an
          // object.
          // 
          // If an object, check whether the 
          // data being queried in this iteration
          // is a single dimensional array. If so,
          // concatenate and return this. If not, 
          // just return the value.
          // 
          // If an array, recursively call this function
          // with the truncated dot notation for each item
          // in the array - allows access of nested data.
          case 'object':
            switch (Array.isArray(property)) {
              case true:
                // The data being queried is an array.
                // Recursively call this function for
                // each item in the array with the truncated
                // dot notation representing the current depth
                // into the original data object.
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                  for (var _iterator = property[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var item = _step.value;
                    data.push(this.getProperty(truncated.join('.'), item));
                  } // Return an array representing the values
                  // of the queried property for each item in
                  // the array.
                  // 
                  // If a nested array has been retrieved as the
                  // property value, concatenate each element.

                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                      _iterator["return"]();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }

                switch (this.rootType) {
                  case 'object':
                    if (data.length > 1 && i == truncated.length - 1 && Array.isArray(data[0])) {
                      return data.map(function (arr) {
                        return arr.filter(function (el) {
                          return el != '';
                        }).join(_this.concatenationCharacters);
                      });
                    } else return data;

                  default:
                    if (data.length > 1 && i == truncated.length && Array.isArray(data)) {
                      return data.filter(function (el) {
                        return el != '';
                      }).join(this.concatenationCharacters);
                    } else return data;

                }

              case false:
                // The data being queried is an object.
                // Check whether the current iteration is
                // the last one.
                // 
                // If so, check whether the value of the queried
                // property is an array. If so, concatenate the
                // values in the array and return as a string.
                // If not, just return the value for the property.
                // 
                // If the current iteration is not the last,
                // dive a level deeper into the data object
                // by accessing the next property in the dot
                // notation, rather than returning it.
                if (i == length - 1) {
                  if (_typeof(property[parts[0]]) == 'object' && Array.isArray(property[parts[0]])) {
                    return property[parts[0]] ? property[parts[0]].join(this.concatenationCharacters) : '';
                  } else {
                    return property[parts[0]] ? property[parts[0]] : '';
                  }
                } else {
                  property = property[parts[i]];
                }

                break;
            }

            break;
          // If the queried data is not
          // an object i.e. a string/number,
          // just return the value.

          default:
            return property;
        }
      }

      return '';
    },
    // Transpose an array.
    // This is used after the data has been filtered to 
    // represent a more csv-like structure.
    transpose: function transpose(data) {
      if (Array.isArray(data) && data.length > 0) {
        return Object.keys(data[0]).map(function (column) {
          return data.map(function (row) {
            return row[column];
          });
        });
      } else return data;
    },
    // Filter the component's data to retrieve only
    // the desired, dot-notated fields.
    filterData: function filterData() {
      // Emit the filtering event, providing the
      // queried field names.
      this.$emit('filtering', {
        unaliasedFields: this.unaliasedFields
      }); // Initialise the array to contain the
      // data to be returned.

      var data = []; // For each queried field, get the desired
      // property and assign it to the data array
      // against a key matching the iteration number.

      for (var i = 0; i < this.unaliasedFields.length; i++) {
        data[i] = this.getProperty(this.unaliasedFields[i], this.unfilteredData);
      } // After being queried, the data array will
      // contain arrays for each queried property,
      // rather than for each row of results.
      // Therefore, it is necessary to transpose the
      // data.


      data = this.transpose(data); // Assign the transposed data
      // to the component's filteredData

      this.filteredData = data; // Emit a filtered event, passing the aliased
      // and unaliased field names, as well as the
      // transposed data.

      this.$emit('filtered', {
        unaliasedFields: this.unaliasedFields,
        aliasedFields: this.aliasedFields,
        data: data
      });
      return data;
    }
  },
  // Component props
  props: {
    // Function used to export the data to
    // csv and trigger a download of the csv.
    exportFunction: {
      "default": function _default() {
        return function (aliasedFields, data) {
          // Emit an exporting event,
          // providing the aliased field
          // names that will be used and
          // the data that will be exported.
          this.$emit('exporting', {
            fields: aliasedFields,
            data: data
          }); // Create a set from the provided
          // fields.

          var fields = _toConsumableArray(new Set(aliasedFields)); // Enclose field names with commas in
          // with speech marks for excel-friendliness


          fields = fields.map(function (field) {
            if (field.includes(',')) {
              // this.warn('Comma detected in field name. Enclosing in double quotes.');
              return '"' + field + '"';
            } else return field;
          }); // Add a comma separated string to the start
          // of the csv array, containing the field
          // names. Create copy with slice to avoid
          // infinite loop errors.

          data = data.slice();
          data.unshift(fields.join(',')); // Join each element in the data array
          // by a newline and carriage return.

          var csvFile = data.join('\r\n'); // Create a blob from the joined data.

          var blob = new Blob([csvFile], {
            type: 'text/csv;charset=utf-8;'
          }); // Get the file name generated by the 
          // fileNameFunction prop.

          var fileName = this.fileNameFunction(); // Download the file.
          // Varies based on browser.

          if (navigator.msSaveBlob) {
            navigator.msSaveBlob(blob, fileName);
          } else {
            var link = document.createElement("a"); // Check for HTML5 download attribute
            // Create an element containing a link
            // to download the file and click it.

            if (link.download !== undefined) {
              var url = URL.createObjectURL(blob);
              link.setAttribute("href", url);
              link.setAttribute("download", fileName);
              link.style.visibility = 'hidden';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            }
          } // Emit an exported event,
          // showing the csv data.


          this.$emit('exported', {
            csv: data
          });
        };
      }
    },
    // Function to generate the file name
    // for download csvs. Defaults to 
    // Report<ms_since_1970>.csv
    fileNameFunction: {
      "default": function _default() {
        return function () {
          return "Report" + Date.now() + ".csv";
        };
      }
    },
    // Prop to control whether the
    // export-button slot is rendered
    showExportButton: {
      "default": function _default() {
        return false;
      }
    },
    // Prop to control whether the
    // table slot is rendered
    showTable: {
      "default": function _default() {
        return false;
      }
    },
    // JSON string to be queried
    json: {
      "default": function _default() {
        return '';
      }
    },
    // Object to be queried.
    // Takes precedence over the
    // json prop if both are provided.
    object: {
      "default": function _default() {
        return {};
      }
    },
    // Fields to be returned.
    // Can be either an array of
    // strings or an array of objects
    // each containing a name and alias
    // property.
    fields: {
      "default": function _default() {
        return [];
      }
    },
    // Prop to control whether console
    // warnings and errors are generated.
    errors: {
      "default": function _default() {
        return true;
      }
    },
    // Prop to control the string used
    // to separate concatenated arrays
    // of values for queried properties.
    // Used where the value for the
    // queried property is a single
    // dimensional array of numbers/strings.
    concatenationCharacters: {
      "default": function _default() {
        return ' | ';
      }
    }
  },
  mounted: function mounted() {//
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

/* script */
var __vue_script__ = script;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "container"
  }, [_vm.fields.length > 0 && this.showTable == true ? _vm._t("table", [_c('table', {
    staticClass: "table is-striped is-hoverable is-bordered is-fullwidth"
  }, [_c('thead', [_c('tr', _vm._l(this.aliasedFields, function (field, index) {
    return _c('td', {
      key: index
    }, [_vm._v(_vm._s(field))]);
  }), 0)]), _vm._v(" "), _c('tbody', _vm._l(this.filterData(), function (row, rowIndex) {
    return _c('tr', {
      key: rowIndex
    }, _vm._l(row, function (field, index) {
      return _c('td', {
        key: index
      }, [_vm._v(_vm._s(field))]);
    }), 0);
  }), 0)])]) : _vm._e(), _vm._v(" "), this.filteredData.length > 0 && this.showExportButton == true ? _vm._t("export-button", [_c('button', {
    staticClass: "button is-link is-fullwidth",
    on: {
      "click": function click($event) {
        return _vm.exportFunction(_vm.aliasedFields, _vm.filteredData);
      }
    }
  }, [_vm._v("Export")])]) : _vm._e()], 2);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = false;
/* style inject */

/* style inject SSR */

var VueNestedJsonToCsv = normalizeComponent_1({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);

var index = {
  install: function install(Vue, options) {
    Vue.component("vue-nested-json-to-csv", VueNestedJsonToCsv);
  }
};

module.exports = index;
